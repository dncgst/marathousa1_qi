## test of uniformity, assessing the significance of the mean resultant length
### assumptions: data are not diametrically bidirectional; data are unimodal (there are no more than one cluster of points around the circle)
### uses the Vector Magnitude L parameter, that makes sense only if the distribution of orientations is not bi- or plurimodal
r.test(bearing)
## omnibus Kuiper test
## one-sample test of uniformity on the circle.
kuiper(bearing)
## omnibus Watson test
## goodness of fit test for the von Mises (dist="vm") or circular uniform (dist="uniform") distribution
## If dist = 'vm', estimates of the population parameters are used to evaluate the von Mises distribution function at all data points, thereby arriving at a sample of approximately uniformly distributed data, if the original observations have a von Mises distribution. The one-sample Watson test is then applied to the transformed data as above.
watson(bearing)
## omnibus Rao's spacing test
## uses the space between observations to determine if the data shows significant directionality. If the data is uniform, observations should tend to be evenly spaced apart.
rao.spacing(bearing)
l <- c(cos(plunge)*cos(bearing))
### m=cos(plunge)*sin(trend)
m <- c(cos(plunge)*sin(bearing))
### n=sin(plunge)
n <- c(sin(plunge))
## step 2) and 3) compute the products of each direction-cosine set. sum the products over the whole data sample to give the orientation tensor
b <- matrix(c(
sum(l^2),sum(l*m),sum(l*n),
sum(m*l),sum(m^2),sum(m*n),
sum(n*l),sum(n*m),sum(n^2)),
ncol=3, byrow=TRUE)
## step 4) compute the eigenvectors and eigenvalues of this matrix
### the eigenvectors (v1,v2,v3) of this matrix correspond to three orthogonal 'principal axes' of the data sample. Axis v1 is an estimate of the mean direction of the data; v3 is the pole to any girdle present in the data [@Watson1966]
eigenvectors <- eigen(b)$vectors
dimnames(eigenvectors) <- list(c("v1","v2","v3"),c("l","m","n"))
### The eigenvalues (λ1,λ2,λ3), associated with (v1,v2,v3) respectively, describe the shape of the data sample [@Watson1966; @Mark1974; @Woodcock1973; @Woodcock1977]
eigenvalues <- eigen(b)$values
names(eigenvalues) <- c("λ1","λ2","λ3")
v1.plunge <- deg(asin(eigenvectors["v1","n"]))
v1.bearing <- deg(acos(eigenvectors["v1","l"]/cos(asin(eigenvectors["v1","n"]))))
v2.plunge <- deg(asin(eigenvectors["v2","n"]))
v2.bearing <- deg(acos(eigenvectors["v2","l"]/cos(asin(eigenvectors["v2","n"]))))
v3.plunge <- deg(asin(eigenvectors["v3","n"]))
v3.bearing <- deg(acos(eigenvectors["v3","l"]/cos(asin(eigenvectors["v3","n"]))))
net()
qpoint(deg(bearing), 90-deg(plunge), col=1, pch=1, cex=1)
qpoint(deg(v1.bearing), 90-deg(v1.plunge), col=4, pch=10, cex=1, lab="v1")
qpoint(deg(v2.bearing), 90-deg(v2.plunge), col=4, pch=10, cex=1, lab="v2")
qpoint(deg(v3.bearing), 90-deg(v3.plunge), col=4, pch=10, cex=1, lab="v3")
#lowplane(270, 3.908544, col="red", UP=TRUE, PLOT=TRUE)
s1 <- eigenvalues["λ1"]/length(plunge)
s2 <- eigenvalues["λ2"]/length(plunge)
s3 <- eigenvalues["λ3"]/length(plunge)
# Elephant (43 obs)
E.s1_s2 <- s1/s2
E.s2_s3 <- s2/s3
E.s1_s3 <- s1/s3
# Elephant (63 obs)
E63.s1_s2 <- s1/s2
E63.s2_s3 <- s2/s3
E63.s1_s3 <- s1/s3
#E.is <- s3/s1
E63.is <- s3/s1
#E.el <- 1-(s2/s1)
E63.el <- 1-(s2/s1)
#E.bs <- 1-(E.is+E.el)
E63.bs <- 1-(E63.is+E63.el)
plunge <- rad(UB4c_clock.fabric$plunge)
bearing <- rad(UB4c_clock.fabric$bearing)
## summary
deg(circ.summary(bearing))
deg(circ.summary(plunge))
## dispersion
deg(circ.disp(bearing))
deg(circ.disp(plunge))
## Rayleigh test: test for unimodal departure from uniformity
## test of uniformity, assessing the significance of the mean resultant length
### assumptions: data are not diametrically bidirectional; data are unimodal (there are no more than one cluster of points around the circle)
### uses the Vector Magnitude L parameter, that makes sense only if the distribution of orientations is not bi- or plurimodal
r.test(bearing)
## omnibus Kuiper test
## one-sample test of uniformity on the circle.
kuiper(bearing)
## omnibus Watson test
## goodness of fit test for the von Mises (dist="vm") or circular uniform (dist="uniform") distribution
## If dist = 'vm', estimates of the population parameters are used to evaluate the von Mises distribution function at all data points, thereby arriving at a sample of approximately uniformly distributed data, if the original observations have a von Mises distribution. The one-sample Watson test is then applied to the transformed data as above.
watson(bearing)
## omnibus Rao's spacing test
## uses the space between observations to determine if the data shows significant directionality. If the data is uniform, observations should tend to be evenly spaced apart.
rao.spacing(bearing)
# Stepwise procedure for the S1/S3 test. Modified from [@Woodcock1983]
## step 1) express each direction in the sample as a set of three direction cosines. If the data are in the form of trend and plunge, the formulae are:
### l=cos(plunge)*cos(trend)
l <- c(cos(plunge)*cos(bearing))
### m=cos(plunge)*sin(trend)
m <- c(cos(plunge)*sin(bearing))
### n=sin(plunge)
n <- c(sin(plunge))
## step 2) and 3) compute the products of each direction-cosine set. sum the products over the whole data sample to give the orientation tensor
b <- matrix(c(
sum(l^2),sum(l*m),sum(l*n),
sum(m*l),sum(m^2),sum(m*n),
sum(n*l),sum(n*m),sum(n^2)),
ncol=3, byrow=TRUE)
## step 4) compute the eigenvectors and eigenvalues of this matrix
### the eigenvectors (v1,v2,v3) of this matrix correspond to three orthogonal 'principal axes' of the data sample. Axis v1 is an estimate of the mean direction of the data; v3 is the pole to any girdle present in the data [@Watson1966]
eigenvectors <- eigen(b)$vectors
dimnames(eigenvectors) <- list(c("v1","v2","v3"),c("l","m","n"))
### The eigenvalues (λ1,λ2,λ3), associated with (v1,v2,v3) respectively, describe the shape of the data sample [@Watson1966; @Mark1974; @Woodcock1973; @Woodcock1977]
eigenvalues <- eigen(b)$values
names(eigenvalues) <- c("λ1","λ2","λ3")
## equal area plot
v1.plunge <- deg(asin(eigenvectors["v1","n"]))
v1.bearing <- deg(acos(eigenvectors["v1","l"]/cos(asin(eigenvectors["v1","n"]))))
v2.plunge <- deg(asin(eigenvectors["v2","n"]))
v2.bearing <- deg(acos(eigenvectors["v2","l"]/cos(asin(eigenvectors["v2","n"]))))
v3.plunge <- deg(asin(eigenvectors["v3","n"]))
v3.bearing <- deg(acos(eigenvectors["v3","l"]/cos(asin(eigenvectors["v3","n"]))))
net()
qpoint(deg(bearing), 90-deg(plunge), col=1, pch=1, cex=1)
qpoint(deg(v1.bearing), 90-deg(v1.plunge), col=4, pch=10, cex=1, lab="v1")
qpoint(deg(v2.bearing), 90-deg(v2.plunge), col=4, pch=10, cex=1, lab="v2")
qpoint(deg(v3.bearing), 90-deg(v3.plunge), col=4, pch=10, cex=1, lab="v3")
#lowplane(270, 3.908544, col="red", UP=TRUE, PLOT=TRUE)
## step 5) compute the eigenvalue ratio, particularly the ratio of the largest to smallest eigenvalue (S1/S3=λ1/λ3)
### since λ1+λ2+λ3=N then normalized eigenvalues Sj=λj/N are related by S1+S2+S3=1. A data cluster has S1>S2~=S3 and a data girdle has S1~=S2>S3
s1 <- eigenvalues["λ1"]/length(plunge)
s2 <- eigenvalues["λ2"]/length(plunge)
s3 <- eigenvalues["λ3"]/length(plunge)
## UB4c_clock
UB4c_clock.s1_s2 <- s1/s2
UB4c_clock.s2_s3 <- s2/s3
UB4c_clock.s1_s3 <- s1/s3
UB4c_clock.is <- s3/s1
UB4c_clock.el <- 1-(s2/s1)
UB4c_clock.bs <- 1-(UB4c_clock.is+UB4c_clock.el)
plunge <- rad(UB4c_comp.fabric$plunge)
bearing <- rad(UB4c_comp.fabric$bearing)
## summary
deg(circ.summary(bearing))
deg(circ.summary(plunge))
## dispersion
deg(circ.disp(bearing))
deg(circ.disp(plunge))
## Rayleigh test: test for unimodal departure from uniformity
## test of uniformity, assessing the significance of the mean resultant length
### assumptions: data are not diametrically bidirectional; data are unimodal (there are no more than one cluster of points around the circle)
### uses the Vector Magnitude L parameter, that makes sense only if the distribution of orientations is not bi- or plurimodal
r.test(bearing)
## omnibus Kuiper test
## one-sample test of uniformity on the circle.
kuiper(bearing)
## omnibus Watson test
## goodness of fit test for the von Mises (dist="vm") or circular uniform (dist="uniform") distribution
## If dist = 'vm', estimates of the population parameters are used to evaluate the von Mises distribution function at all data points, thereby arriving at a sample of approximately uniformly distributed data, if the original observations have a von Mises distribution. The one-sample Watson test is then applied to the transformed data as above.
watson(bearing)
## omnibus Rao's spacing test
## uses the space between observations to determine if the data shows significant directionality. If the data is uniform, observations should tend to be evenly spaced apart.
rao.spacing(bearing)
## step 1) express each direction in the sample as a set of three direction cosines. If the data are in the form of trend and plunge, the formulae are:
### l=cos(plunge)*cos(trend)
l <- c(cos(plunge)*cos(bearing))
### m=cos(plunge)*sin(trend)
m <- c(cos(plunge)*sin(bearing))
### n=sin(plunge)
n <- c(sin(plunge))
## step 2) and 3) compute the products of each direction-cosine set. sum the products over the whole data sample to give the orientation tensor
b <- matrix(c(
sum(l^2),sum(l*m),sum(l*n),
sum(m*l),sum(m^2),sum(m*n),
sum(n*l),sum(n*m),sum(n^2)),
ncol=3, byrow=TRUE)
## step 4) compute the eigenvectors and eigenvalues of this matrix
### the eigenvectors (v1,v2,v3) of this matrix correspond to three orthogonal 'principal axes' of the data sample. Axis v1 is an estimate of the mean direction of the data; v3 is the pole to any girdle present in the data [@Watson1966]
eigenvectors <- eigen(b)$vectors
dimnames(eigenvectors) <- list(c("v1","v2","v3"),c("l","m","n"))
### The eigenvalues (λ1,λ2,λ3), associated with (v1,v2,v3) respectively, describe the shape of the data sample [@Watson1966; @Mark1974; @Woodcock1973; @Woodcock1977]
eigenvalues <- eigen(b)$values
names(eigenvalues) <- c("λ1","λ2","λ3")
## equal area plot
v1.plunge <- deg(asin(eigenvectors["v1","n"]))
v1.bearing <- deg(acos(eigenvectors["v1","l"]/cos(asin(eigenvectors["v1","n"]))))
v2.plunge <- deg(asin(eigenvectors["v2","n"]))
v2.bearing <- deg(acos(eigenvectors["v2","l"]/cos(asin(eigenvectors["v2","n"]))))
v3.plunge <- deg(asin(eigenvectors["v3","n"]))
v3.bearing <- deg(acos(eigenvectors["v3","l"]/cos(asin(eigenvectors["v3","n"]))))
net()
qpoint(deg(bearing), 90-deg(plunge), col=1, pch=1, cex=1)
qpoint(deg(v1.bearing), 90-deg(v1.plunge), col=4, pch=10, cex=1, lab="v1")
qpoint(deg(v2.bearing), 90-deg(v2.plunge), col=4, pch=10, cex=1, lab="v2")
qpoint(deg(v3.bearing), 90-deg(v3.plunge), col=4, pch=10, cex=1, lab="v3")
#lowplane(270, 3.908544, col="red", UP=TRUE, PLOT=TRUE)
```
## step 5) compute the eigenvalue ratio, particularly the ratio of the largest to smallest eigenvalue (S1/S3=λ1/λ3)
### since λ1+λ2+λ3=N then normalized eigenvalues Sj=λj/N are related by S1+S2+S3=1. A data cluster has S1>S2~=S3 and a data girdle has S1~=S2>S3
s1 <- eigenvalues["λ1"]/length(plunge)
s2 <- eigenvalues["λ2"]/length(plunge)
s3 <- eigenvalues["λ3"]/length(plunge)
# UB4c_comp
UB4c_comp.s1_s2 <- s1/s2
UB4c_comp.s2_s3 <- s2/s3
UB4c_comp.s1_s3 <- s1/s3
UB4c_comp.is <- s3/s1
UB4c_comp.el <- 1-(s2/s1)
UB4c_comp.bs <- 1-(UB4c_comp.is+UB4c_comp.el)
summary(UB4c_test.fabric)
# mean
deg(circ.mean(rad(UB4c_test.fabric$bearing_clock)))
deg(circ.mean(rad(UB4c_test.fabric$bearing_comp)))
# rose diagrams
heR.Misc::rose(UB4c_test.fabric$bearing_clock, bins=72, col="red", rings=TRUE, labels=TRUE, rscale=2, main="")
heR.Misc::rose(UB4c_test.fabric$bearing_comp, bins=72, col="red", rings=TRUE, labels=TRUE, rscale=2, main="")
# uniformity tests
r.test(rad(UB4c_test.fabric$bearing_clock))
r.test(rad(UB4c_test.fabric$bearing_comp))
kuiper(rad(UB4c_test.fabric$bearing_clock))
kuiper(rad(UB4c_test.fabric$bearing_comp))
watson(rad(UB4c_test.fabric$bearing_clock))
watson(rad(UB4c_test.fabric$bearing_comp))
rao.spacing(rad(UB4c_test.fabric$bearing_clock))
rao.spacing(rad(UB4c_test.fabric$bearing_comp))
# Angles are in radians, not degrees!!!
plunge <- rad(UB4c_test.fabric$plunge_clock)
bearing <- rad(UB4c_test.fabric$bearing_clock)
## step 1) express each direction in the sample as a set of three direction cosines. If the data are in the form of trend and plunge, the formulae are:
### l=cos(plunge)*cos(trend)
l <- c(cos(plunge)*cos(bearing))
### m=cos(plunge)*sin(trend)
m <- c(cos(plunge)*sin(bearing))
### n=sin(plunge)
n <- c(sin(plunge))
## step 2) and 3) compute the products of each direction-cosine set. sum the products over the whole data sample to give the orientation tensor
b <- matrix(c(
sum(l^2),sum(l*m),sum(l*n),
sum(m*l),sum(m^2),sum(m*n),
sum(n*l),sum(n*m),sum(n^2)),
ncol=3, byrow=TRUE)
## step 4) compute the eigenvectors and eigenvalues of this matrix
### the eigenvectors (v1,v2,v3) of this matrix correspond to three orthogonal 'principal axes' of the data sample. Axis v1 is an estimate of the mean direction of the data; v3 is the pole to any girdle present in the data [@Watson1966]
eigenvectors <- eigen(b)$vectors
dimnames(eigenvectors) <- list(c("v1","v2","v3"),c("l","m","n"))
### The eigenvalues (λ1,λ2,λ3), associated with (v1,v2,v3) respectively, describe the shape of the data sample [@Watson1966; @Mark1974; @Woodcock1973; @Woodcock1977]
eigenvalues <- eigen(b)$values
names(eigenvalues) <- c("λ1","λ2","λ3")
## step 5) compute the eigenvalue ratio, particularly the ratio of the largest to smallest eigenvalue (S1/S3=λ1/λ3)
### since λ1+λ2+λ3=N then normalized eigenvalues Sj=λj/N are related by S1+S2+S3=1. A data cluster has S1>S2~=S3 and a data girdle has S1~=S2>S3
s1 <- eigenvalues["λ1"]/length(plunge)
s2 <- eigenvalues["λ2"]/length(plunge)
s3 <- eigenvalues["λ3"]/length(plunge)
# save UB4c_clock
clock.s1_s2 <- s1/s2
clock.s2_s3 <- s2/s3
clock.s1_s3 <- s1/s3
clock.is <- s3/s1
clock.el <- 1-(s2/s1)
clock.bs <- 1-(clock.is+clock.el)
plunge <- rad(UB4c_test.fabric$plunge_comp)
bearing <- rad(UB4c_test.fabric$bearing_comp)
# Woodcock diagram
## step 1) express each direction in the sample as a set of three direction cosines. If the data are in the form of trend and plunge, the formulae are:
### l=cos(plunge)*cos(trend)
l <- c(cos(plunge)*cos(bearing))
### m=cos(plunge)*sin(trend)
m <- c(cos(plunge)*sin(bearing))
### n=sin(plunge)
n <- c(sin(plunge))
## step 2) and 3) compute the products of each direction-cosine set. sum the products over the whole data sample to give the orientation tensor
b <- matrix(c(
sum(l^2),sum(l*m),sum(l*n),
sum(m*l),sum(m^2),sum(m*n),
sum(n*l),sum(n*m),sum(n^2)),
ncol=3, byrow=TRUE)
## step 4) compute the eigenvectors and eigenvalues of this matrix
### the eigenvectors (v1,v2,v3) of this matrix correspond to three orthogonal 'principal axes' of the data sample. Axis v1 is an estimate of the mean direction of the data; v3 is the pole to any girdle present in the data [@Watson1966]
eigenvectors <- eigen(b)$vectors
dimnames(eigenvectors) <- list(c("v1","v2","v3"),c("l","m","n"))
### The eigenvalues (λ1,λ2,λ3), associated with (v1,v2,v3) respectively, describe the shape of the data sample [@Watson1966; @Mark1974; @Woodcock1973; @Woodcock1977]
eigenvalues <- eigen(b)$values
names(eigenvalues) <- c("λ1","λ2","λ3")
## step 5) compute the eigenvalue ratio, particularly the ratio of the largest to smallest eigenvalue (S1/S3=λ1/λ3)
### since λ1+λ2+λ3=N then normalized eigenvalues Sj=λj/N are related by S1+S2+S3=1. A data cluster has S1>S2~=S3 and a data girdle has S1~=S2>S3
s1 <- eigenvalues["λ1"]/length(plunge)
s2 <- eigenvalues["λ2"]/length(plunge)
s3 <- eigenvalues["λ3"]/length(plunge)
# save UB4c_comp
comp.s1_s2 <- s1/s2
comp.s2_s3 <- s2/s3
comp.s1_s3 <- s1/s3
comp.is <- s3/s1
comp.el <- 1-(s2/s1)
comp.bs <- 1-(comp.is+comp.el)
setEPS()
pdf("./doc/artwork/FigSI1.pdf", width=10, height=10)
par(ps=12, cex=1, cex.main=2, cex.axis=1, cex.lab=1)
plot(log(UA3c.comp.s2_s3),log(UA3c.comp.s1_s2),pch=15,xlim=c(0,3),ylim=c(0,3),xlab="ln S2/S3",ylab="ln S1/S2", main="a")
plot(log(comp.s2_s3),log(comp.s1_s2),pch=15,xlim=c(0,3),ylim=c(0,3),xlab="ln S2/S3",ylab="ln S1/S2", main="a")
## shape parameter K=ln(S1/S2)/ln(S2/S3) ranges from 0 (uniaxial girdles) to infinite (uniaxial clusters)
abline(h=0,col="grey",lty=2)
abline(v=0,col="grey",lty=2)
abline(0,1,col="grey",lty=2)
abline(0,2,col="grey",lty=2)
abline(0,.5,col="grey",lty=2)
abline(0,5,col="grey",lty=2)
abline(0,.2,col="grey",lty=2)
text(2.95,2.8,label="K=1",col="grey",lwd=.02)
text(2.95,.1,label="K=0",col="grey",lwd=.02)
text(.2,3,label=expression(paste("K=",infinity)),col="grey",lwd=.02)
text(2.95,.75,label="K=0.2",col="grey",lwd=.02)
text(2.95,1.65,label="K=0.5",col="grey",lwd=.02)
text(.8,3,label="K=5",col="grey",lwd=.02)
text(1.7,3,label="K=2",col="grey",lwd=.02)
## complementary to the shape parameter is the parameter C=ln(S1/S3) which expresses the 'strength' of the preferred orientation in the data sample [@Woodcock1977]. Strongly organized samples have larger C and plot further from the origin of the ratio graph. A perfect uniform distribution of data would have C=0 and would plot at the origin with S1=S2=S3=1/3. Random samples will also plot close to the origin and have low C values, suggesting that this parameter might be used as a test statistic for randomness
abline(3,-1,col="grey",lty=1)
text(1.7,1.5,label="C=3",col="grey",lwd=.02)
PlotPTsmooth(deg(UB4c_test.fabric$bearing_clock),deg(UB4c_test.fabric$plunge_clock),x=log(clock.s2_s3),y=log(clock.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.25,.33,label="UB4c (clock)",col="black",lwd=.02)
PlotPTsmooth(deg(UB4c_test.fabric$bearing_comp),deg(UB4c_test.fabric$plunge_comp),x=log(comp.s2_s3),y=log(comp.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.65,.25,label="UB4c (comp)",col="black",lwd=.02)
text(1.45,1.65,label="WEAK <--> STRONG",col="gray",lwd=.03,srt=45,pos=1)
text(2.55,2.63,label="<-- CLUSTERS | GIRDLES -->",col="gray",lwd=.03,srt=-45,pos=1)
dev.off()
plot(log(comp.s2_s3),log(comp.s1_s2),pch=15,xlim=c(0,3),ylim=c(0,3),xlab="ln S2/S3",ylab="ln S1/S2", main="Woodcock diagram")
## shape parameter K=ln(S1/S2)/ln(S2/S3) ranges from 0 (uniaxial girdles) to infinite (uniaxial clusters)
abline(h=0,col="grey",lty=2)
abline(v=0,col="grey",lty=2)
abline(0,1,col="grey",lty=2)
abline(0,2,col="grey",lty=2)
abline(0,.5,col="grey",lty=2)
abline(0,5,col="grey",lty=2)
abline(0,.2,col="grey",lty=2)
text(2.95,2.8,label="K=1",col="grey",lwd=.02)
text(2.95,.1,label="K=0",col="grey",lwd=.02)
text(.2,3,label=expression(paste("K=",infinity)),col="grey",lwd=.02)
text(2.95,.75,label="K=0.2",col="grey",lwd=.02)
text(2.95,1.65,label="K=0.5",col="grey",lwd=.02)
text(.8,3,label="K=5",col="grey",lwd=.02)
text(1.7,3,label="K=2",col="grey",lwd=.02)
## complementary to the shape parameter is the parameter C=ln(S1/S3) which expresses the 'strength' of the preferred orientation in the data sample [@Woodcock1977]. Strongly organized samples have larger C and plot further from the origin of the ratio graph. A perfect uniform distribution of data would have C=0 and would plot at the origin with S1=S2=S3=1/3. Random samples will also plot close to the origin and have low C values, suggesting that this parameter might be used as a test statistic for randomness
abline(3,-1,col="grey",lty=1)
text(1.7,1.5,label="C=3",col="grey",lwd=.02)
PlotPTsmooth(deg(UB4c_test.fabric$bearing_clock),deg(UB4c_test.fabric$plunge_clock),x=log(clock.s2_s3),y=log(clock.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.25,.33,label="UB4c (clock)",col="black",lwd=.02)
PlotPTsmooth(deg(UB4c_test.fabric$bearing_comp),deg(UB4c_test.fabric$plunge_comp),x=log(comp.s2_s3),y=log(comp.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.65,.25,label="UB4c (comp)",col="black",lwd=.02)
text(.25,.35,label="UB4c (clock)",col="black",lwd=.02)
text(.25,.45,label="UB4c (clock)",col="black",lwd=.02)
text(.75,.25,label="UB4c (comp)",col="black",lwd=.02)
text(.85,.25,label="UB4c (comp)",col="black",lwd=.02)
text(.95,.25,label="UB4c (comp)",col="black",lwd=.02)
setEPS()
pdf("./doc/artwork/FigSI1.pdf", width=10, height=10)
par(ps=12, cex=1, cex.main=2, cex.axis=1, cex.lab=1)
plot(log(comp.s2_s3),log(comp.s1_s2),pch=15,xlim=c(0,3),ylim=c(0,3),xlab="ln S2/S3",ylab="ln S1/S2", main="Woodcock diagram")
## shape parameter K=ln(S1/S2)/ln(S2/S3) ranges from 0 (uniaxial girdles) to infinite (uniaxial clusters)
abline(h=0,col="grey",lty=2)
abline(v=0,col="grey",lty=2)
abline(0,1,col="grey",lty=2)
abline(0,2,col="grey",lty=2)
abline(0,.5,col="grey",lty=2)
abline(0,5,col="grey",lty=2)
abline(0,.2,col="grey",lty=2)
text(2.95,2.8,label="K=1",col="grey",lwd=.02)
text(2.95,.1,label="K=0",col="grey",lwd=.02)
text(.2,3,label=expression(paste("K=",infinity)),col="grey",lwd=.02)
text(2.95,.75,label="K=0.2",col="grey",lwd=.02)
text(2.95,1.65,label="K=0.5",col="grey",lwd=.02)
text(.8,3,label="K=5",col="grey",lwd=.02)
text(1.7,3,label="K=2",col="grey",lwd=.02)
## complementary to the shape parameter is the parameter C=ln(S1/S3) which expresses the 'strength' of the preferred orientation in the data sample [@Woodcock1977]. Strongly organized samples have larger C and plot further from the origin of the ratio graph. A perfect uniform distribution of data would have C=0 and would plot at the origin with S1=S2=S3=1/3. Random samples will also plot close to the origin and have low C values, suggesting that this parameter might be used as a test statistic for randomness
abline(3,-1,col="grey",lty=1)
text(1.7,1.5,label="C=3",col="grey",lwd=.02)
##
PlotPTsmooth(deg(UB4c_test.fabric$bearing_clock),deg(UB4c_test.fabric$plunge_clock),x=log(clock.s2_s3),y=log(clock.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.25,.45,label="UB4c (clock)",col="black",lwd=.02)
PlotPTsmooth(deg(UB4c_test.fabric$bearing_comp),deg(UB4c_test.fabric$plunge_comp),x=log(comp.s2_s3),y=log(comp.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.95,.25,label="UB4c (comp)",col="black",lwd=.02)
text(1.45,1.65,label="WEAK <--> STRONG",col="gray",lwd=.03,srt=45,pos=1)
text(2.55,2.63,label="<-- CLUSTERS | GIRDLES -->",col="gray",lwd=.03,srt=-45,pos=1)
dev.off()
setEPS()
pdf("./doc/artwork/FigSI1.pdf", width=10, height=10)
par(ps=12, cex=1, cex.main=2, cex.axis=1, cex.lab=1)
plot(log(comp.s2_s3),log(comp.s1_s2),pch=15,xlim=c(0,3),ylim=c(0,3),xlab="ln S2/S3",ylab="ln S1/S2", main="Woodcock diagram")
## shape parameter K=ln(S1/S2)/ln(S2/S3) ranges from 0 (uniaxial girdles) to infinite (uniaxial clusters)
abline(h=0,col="grey",lty=2)
abline(v=0,col="grey",lty=2)
abline(0,1,col="grey",lty=2)
abline(0,2,col="grey",lty=2)
abline(0,.5,col="grey",lty=2)
abline(0,5,col="grey",lty=2)
abline(0,.2,col="grey",lty=2)
text(2.95,2.8,label="K=1",col="grey",lwd=.02)
text(2.95,.1,label="K=0",col="grey",lwd=.02)
text(.2,3,label=expression(paste("K=",infinity)),col="grey",lwd=.02)
text(2.95,.75,label="K=0.2",col="grey",lwd=.02)
text(2.95,1.65,label="K=0.5",col="grey",lwd=.02)
text(.8,3,label="K=5",col="grey",lwd=.02)
text(1.7,3,label="K=2",col="grey",lwd=.02)
## complementary to the shape parameter is the parameter C=ln(S1/S3) which expresses the 'strength' of the preferred orientation in the data sample [@Woodcock1977]. Strongly organized samples have larger C and plot further from the origin of the ratio graph. A perfect uniform distribution of data would have C=0 and would plot at the origin with S1=S2=S3=1/3. Random samples will also plot close to the origin and have low C values, suggesting that this parameter might be used as a test statistic for randomness
abline(3,-1,col="grey",lty=1)
text(1.7,1.5,label="C=3",col="grey",lwd=.02)
##
PlotPTsmooth(deg(UB4c_test.fabric$bearing_clock),deg(UB4c_test.fabric$plunge_clock),x=log(clock.s2_s3),y=log(clock.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.25,.35,label="UB4c (clock)",col="black",lwd=.02)
PlotPTsmooth(deg(UB4c_test.fabric$bearing_comp),deg(UB4c_test.fabric$plunge_comp),x=log(comp.s2_s3),y=log(comp.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.85,.25,label="UB4c (comp)",col="black",lwd=.02)
text(1.45,1.65,label="WEAK <--> STRONG",col="gray",lwd=.03,srt=45,pos=1)
text(2.55,2.63,label="<-- CLUSTERS | GIRDLES -->",col="gray",lwd=.03,srt=-45,pos=1)
dev.off()
setEPS()
pdf("./doc/artwork/FigSI1.pdf", width=10, height=10)
par(ps=12, cex=1, cex.main=2, cex.axis=1, cex.lab=1)
plot(log(comp.s2_s3),log(comp.s1_s2),pch=15,xlim=c(0,3),ylim=c(0,3),xlab="ln S2/S3",ylab="ln S1/S2", main="Woodcock diagram")
## shape parameter K=ln(S1/S2)/ln(S2/S3) ranges from 0 (uniaxial girdles) to infinite (uniaxial clusters)
abline(h=0,col="grey",lty=2)
abline(v=0,col="grey",lty=2)
abline(0,1,col="grey",lty=2)
abline(0,2,col="grey",lty=2)
abline(0,.5,col="grey",lty=2)
abline(0,5,col="grey",lty=2)
abline(0,.2,col="grey",lty=2)
text(2.95,2.8,label="K=1",col="grey",lwd=.02)
text(2.95,.1,label="K=0",col="grey",lwd=.02)
text(.2,3,label=expression(paste("K=",infinity)),col="grey",lwd=.02)
text(2.95,.75,label="K=0.2",col="grey",lwd=.02)
text(2.95,1.65,label="K=0.5",col="grey",lwd=.02)
text(.8,3,label="K=5",col="grey",lwd=.02)
text(1.7,3,label="K=2",col="grey",lwd=.02)
## complementary to the shape parameter is the parameter C=ln(S1/S3) which expresses the 'strength' of the preferred orientation in the data sample [@Woodcock1977]. Strongly organized samples have larger C and plot further from the origin of the ratio graph. A perfect uniform distribution of data would have C=0 and would plot at the origin with S1=S2=S3=1/3. Random samples will also plot close to the origin and have low C values, suggesting that this parameter might be used as a test statistic for randomness
abline(3,-1,col="grey",lty=1)
text(1.7,1.5,label="C=3",col="grey",lwd=.02)
##
PlotPTsmooth(deg(UB4c_test.fabric$bearing_clock),deg(UB4c_test.fabric$plunge_clock),x=log(clock.s2_s3),y=log(clock.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.25,.40,label="UB4c (clock)",col="black",lwd=.02)
PlotPTsmooth(deg(UB4c_test.fabric$bearing_comp),deg(UB4c_test.fabric$plunge_comp),x=log(comp.s2_s3),y=log(comp.s1_s2),siz=0.1,IMAGE=TRUE,CONT=TRUE,add=TRUE)
text(.80,.20,label="UB4c (comp)",col="black",lwd=.02)
text(1.45,1.65,label="WEAK <--> STRONG",col="gray",lwd=.03,srt=45,pos=1)
text(2.55,2.63,label="<-- CLUSTERS | GIRDLES -->",col="gray",lwd=.03,srt=-45,pos=1)
dev.off()
triax.plot(matrix(c(comp.bs,comp.el,comp.is),ncol=3,byrow=2), show.grid=TRUE, pch=16, cex.ticks=.8, cex.axis=1, axis.labels=c("","Elongation Index\n EL=1-(S2/S1)","Isotropy Index\n IS=S3/S1"), tick.labels=list(l=seq(0.1,0.9,by=0.1), r=seq(0.1,0.9,by=0.1), b=NULL)) #, main="Benn diagram")
triax.plot(matrix(c(comp.bs,comp.el,comp.is),ncol=3,byrow=2), show.grid=TRUE, pch=16, cex.ticks=.8, cex.axis=1, axis.labels=c("","Elongation Index\n EL=1-(S2/S1)","Isotropy Index\n IS=S3/S1"), tick.labels=list(l=seq(0.1,0.9,by=0.1), r=seq(0.1,0.9,by=0.1), b=NULL), main="Benn diagram")
triax.points(matrix(c(clock.bs,clock.el,clock.is),ncol=3,byrow=2), pch=16, cex=2, col="#a51e37")
text(.42,.53,label="UB4c clock")
triax.points(matrix(c(comp.bs,comp.el,comp.is),ncol=3,byrow=2), pch=16, cex=2, col="#a51e37")
text(.48,.35,label="UB4c comp")
text(0.5,0.9,label="isotropic")
text(-0.1,0,label="planar")
text(1.1,0,label="linear")
text(.48,.40,label="UB4c comp")
setEPS()
pdf("./doc/artwork/FigSI2.pdf", width=12, height=10)
par(ps=12, cex=1, cex.main=2, cex.axis=1, cex.lab=1)
triax.plot(matrix(c(comp.bs,comp.el,comp.is),ncol=3,byrow=2), show.grid=TRUE, pch=16, cex.ticks=.8, cex.axis=1, axis.labels=c("","Elongation Index\n EL=1-(S2/S1)","Isotropy Index\n IS=S3/S1"), tick.labels=list(l=seq(0.1,0.9,by=0.1), r=seq(0.1,0.9,by=0.1), b=NULL), main="Benn diagram")
triax.points(matrix(c(clock.bs,clock.el,clock.is),ncol=3,byrow=2), pch=16, cex=2, col="#a51e37")
text(.42,.53,label="UB4c clock")
triax.points(matrix(c(comp.bs,comp.el,comp.is),ncol=3,byrow=2), pch=16, cex=2, col="#a51e37")
text(.48,.40,label="UB4c comp")
text(0.5,0.9,label="isotropic")
text(-0.1,0,label="planar")
text(1.1,0,label="linear")
dev.off()
# TwoSampleQQ
#"The angular QQ-plot is proposed by Fisher (1993) as an alternative graphical
#means of comparing the distributional shape of two samples; but not any
#differences in their central directions, as both samples are centred around
#their median directions in the construction of the plot" (Pewsey, A.;
#Neuhauser, M. & Ruxton, G. D. Circular Statistics in R Oxford University Press,
#2013, p.132)
# http://circstatinr.st-andrews.ac.uk/
# http://circstatinr.st-andrews.ac.uk/resources/Chap7-RCommands.txt
TwoSampleQQ <- function(cdat1, cdat2) {
n1 <- length(cdat1) ; n2 <- length(cdat2) ; nmin <- min(n1,n2) ; nmax <- max(n1,n2)
cdatref <- cdat1 ; cdatoth <- cdat2
if (n2 < n1) { cdatref <- cdat2 ; cdatoth <- cdat1 }
zref <- sin(0.5*(cdatref-median.circular(cdatref))) ; szref <- sort(zref)
zoth <- sin(0.5*(cdatoth-median.circular(cdatoth))) ; szoth <- sort(zoth)
koth <- 0 ; szothred <- 0 ; szreffin <- 0
for (k in 1:nmin) { koth[k] <- 1+nmax*(k-0.5)/nmin ; szothred[k] <- szoth[koth[k]] ; szreffin[k] <- szref[k]}
par(mai=c(0.90, 0.9, 0.05, 0.1), cex.axis=1.2, cex.lab=1.5)
plot(szreffin, szothred, pch=16, xlim=c(-1,1), ylim=c(-1,1), xlab = "Smaller sample", ylab = "Larger sample")
xlim <- c(-1,1) ; ylim <- c(-1,1) ; lines(xlim, ylim, lwd=2, lty=2)
}
?pi
cdat1 <- circular(UB4c_test.fabric$bearing_clock, units="degrees", zero=pi/2, rotation="clock")
plot(cdat1, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
# rose diagrams
heR.Misc::rose(UB4c_test.fabric$bearing_clock, bins=72, col="red", rings=TRUE, labels=TRUE, rscale=2, main="")
heR.Misc::rose(UB4c_test.fabric$bearing_comp, bins=72, col="red", rings=TRUE, labels=TRUE, rscale=2, main="")
cdat2 <- circular(UB4c_test.fabric$bearing_comp, units="degrees", zero=pi/2, rotation="clock")
plot(cdat2, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
arrows.circular(mean(cdat2), y=rho.circular(cdat2), lty=1, lwd=2)
arrows.circular(median(cdat2), y=rho.circular(cdat2), lty=2, lwd=3)
cdat1 <- circular(UB4c_test.fabric$bearing_clock*2*pi/360)
cdat2 <- circular(UB4c_test.fabric$bearing_comp*2*pi/360)
TwoSampleQQ(cdat1, cdat2)
plot(cdat1, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
arrows.circular(mean(cdat1), y=rho.circular(cdat1), lty=1, lwd=2)
arrows.circular(median(cdat1), y=rho.circular(cdat1), lty=2, lwd=3)
plot(cdat2, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
arrows.circular(mean(cdat2), y=rho.circular(cdat2), lty=1, lwd=2)
arrows.circular(median(cdat2), y=rho.circular(cdat2), lty=2, lwd=3)
cdat1 <- circular(UB4c_test.fabric$bearing_clock, units="degrees", zero=pi/2, rotation="clock")
plot(cdat1, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
arrows.circular(mean(cdat1), y=rho.circular(cdat1), lty=1, lwd=2)
arrows.circular(median(cdat1), y=rho.circular(cdat1), lty=2, lwd=3)
cdat2 <- circular(UB4c_test.fabric$bearing_comp, units="degrees", zero=pi/2, rotation="clock")
plot(cdat2, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
arrows.circular(mean(cdat2), y=rho.circular(cdat2), lty=1, lwd=2)
arrows.circular(median(cdat2), y=rho.circular(cdat2), lty=2, lwd=3)
cdat1 <- circular(UB4c_test.fabric$bearing_clock*2*pi/360)
cdat1 <- circular(UB4c_test.fabric$bearing_clock, units="degrees", zero=pi/2, rotation="clock")
plot(cdat1, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
cdat2 <- circular(UB4c_test.fabric$bearing_comp, units="degrees", zero=pi/2, rotation="clock")
plot(cdat2, stack=TRUE, bins=720, cex=1.2, sep=0.04, shrink=0.95)
watson.two.test(cdat1,cdat2)
?watson.two.test
watson.two.test(cdat1,cdat2,alpha = 0.05)
kuiper(rad(UB4c_test.fabric$bearing_clock))
